<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js - Paralelep√≠pedo com Cilindros e Controle WebSocket</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #111; }
    canvas { display: block; }

    /* Estilo da imagem de status */
    #statusImg {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      max-width: 200px;
      display: none; /* come√ßa escondida */
      z-index: 10;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>
<body>
  <!-- Imagem que ser√° trocada -->
  <img id="statusImg" src="" alt="Status" />

  <script>
    // Cena
    const scene = new THREE.Scene();

    // C√¢mera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    // Renderizador
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Luzes
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambient);

    // Grupo principal
    const grupo = new THREE.Group();

    // Paralelep√≠pedo
    const parWidth = 2;
    const parHeight = 1;
    const parDepth = 0.5;
    const parGeometry = new THREE.BoxGeometry(parWidth, parHeight, parDepth);
    const parMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const paralelepipedo = new THREE.Mesh(parGeometry, parMaterial);
    grupo.add(paralelepipedo);

    // Linhas de arestas do paralelep√≠pedo
    const parEdges = new THREE.EdgesGeometry(parGeometry);
    const parLines = new THREE.LineSegments(
      parEdges,
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    grupo.add(parLines);

    // Par√¢metros dos cilindros
    const cylRadius = 0.02;
    const cylHeight = 0.1;
    const cylGeometry = new THREE.CylinderGeometry(cylRadius, cylRadius, cylHeight, 32);
    const cylMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

    // Array para guardar os cilindros
    const cilindros = [];

    // Fun√ß√£o para criar cilindros nas pontas da face direita
    function criarCilindro(x, y, z) {
      const cilindro = new THREE.Mesh(cylGeometry, cylMaterial);
      cilindro.rotation.z = Math.PI / 2;
      cilindro.position.set(x, y, z);
      grupo.add(cilindro);
      cilindros.push(cilindro);
    }

    // Coordenadas
    const xCilindro = parWidth / 2 + cylHeight / 2;
    const yTop = parHeight / 2 - cylRadius;
    const yBottom = -parHeight / 2 + cylRadius;
    const zFront = parDepth / 2 - cylRadius;
    const zBack = -parDepth / 2 + cylRadius;

    criarCilindro(xCilindro, yTop, zFront);
    criarCilindro(xCilindro, yTop, zBack);
    criarCilindro(xCilindro, yBottom, zFront);
    criarCilindro(xCilindro, yBottom, zBack);

    scene.add(grupo);

    // Controle de rota√ß√£o com mouse
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    document.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const delta = {
        x: e.clientX - previousMousePosition.x,
        y: e.clientY - previousMousePosition.y,
      };
      const speed = 0.005;
      grupo.rotation.y += delta.x * speed;
      grupo.rotation.x += delta.y * speed;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    // Zoom
    window.addEventListener('wheel', (e) => {
      const zoomSpeed = 0.1;
      camera.position.z += e.deltaY * zoomSpeed;
      camera.position.z = Math.max(2, Math.min(20, camera.position.z));
    });

    // Resize responsivo
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Elemento de imagem
    const statusImg = document.getElementById("statusImg");

    // WebSocket
    let socket;
    try {
      socket = new WebSocket('ws://localhost:1880/ws');

      socket.onopen = () => {
        console.log("‚úÖ WebSocket conectado ao servidor.");
      };

      socket.onerror = (error) => {
        console.error("‚ùå Erro na conex√£o WebSocket:", error);
      };

      socket.onmessage = (event) => {
        const comando = event.data.trim();
        console.log("üì© Comando recebido:", comando);

        if (comando === "hide_cylinders") {
          cilindros.forEach(c => c.visible = false);
          statusImg.style.display = "none";
        } else if (comando === "show_cylinders") {
          cilindros.forEach(c => c.visible = true);
          statusImg.style.display = "none";
        } else if (comando === "pass") {
          statusImg.src = "PASS.png";
          statusImg.style.display = "block";
        } else if (comando === "fail") {
          statusImg.src = "FAIL.png";
          statusImg.style.display = "block";
        } else {
          console.warn("‚ö†Ô∏è Comando desconhecido:", comando);
        }
      };

      socket.onclose = () => {
        console.warn("üîå Conex√£o WebSocket encerrada.");
      };
    } catch (e) {
      console.error("‚ùå Erro ao tentar criar WebSocket:", e);
    }

    // Loop de renderiza√ß√£o
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
