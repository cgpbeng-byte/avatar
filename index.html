<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js - Paralelepípedo com 4 Cilindros nas Pontas</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>
<body>
  <script>
    // Cena
    const scene = new THREE.Scene();

    // Câmera
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 5;

    // Renderizador
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // Luzes
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);
    const ambient = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambient);

    // Grupo para unir os objetos
    const grupo = new THREE.Group();

    // Paralelepípedo
    const parWidth = 2;
    const parHeight = 1;
    const parDepth = 0.5;
    const parGeometry = new THREE.BoxGeometry(parWidth, parHeight, parDepth);
    const parMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
    const paralelepipedo = new THREE.Mesh(parGeometry, parMaterial);
    grupo.add(paralelepipedo);

    // Linhas de arestas do paralelepípedo (brancas)
    const parEdges = new THREE.EdgesGeometry(parGeometry);
    const parLines = new THREE.LineSegments(
      parEdges,
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    grupo.add(parLines);

    // Parâmetros dos cilindros
    const cylRadius = 0.02;
    const cylHeight = 0.1;
    const cylGeometry = new THREE.CylinderGeometry(cylRadius, cylRadius, cylHeight, 32);
    const cylMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });

    // Função para criar cilindro na posição desejada
    function criarCilindro(x, y, z) {
      const cilindro = new THREE.Mesh(cylGeometry, cylMaterial);
      cilindro.rotation.z = Math.PI / 2; // Deitado
      cilindro.position.set(x, y, z);
      grupo.add(cilindro);
    }

    // Posiciona os 4 cilindros nas pontas da face lateral direita do paralelepípedo
    // Face lateral direita está em x = parWidth/2 + cylHeight/2 (distância lateral)
    // Pontas correspondem aos 4 cantos na face lateral: combinações de y e z
    const posX = parWidth / 2 + cylHeight / 2;
    const posYTop = parHeight / 2 - cylRadius;
    const posYBottom = -parHeight / 2 + cylRadius;
    const posZFront = parDepth / 2 - cylRadius;
    const posZBack = -parDepth / 2 + cylRadius;

    criarCilindro(posX, posYTop, posZFront);     // canto superior frontal
    criarCilindro(posX, posYTop, posZBack);      // canto superior traseiro
    criarCilindro(posX, posYBottom, posZFront);  // canto inferior frontal
    criarCilindro(posX, posYBottom, posZBack);   // canto inferior traseiro

    // Adiciona o grupo à cena
    scene.add(grupo);

    // Controle de rotação com o mouse
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };

    document.addEventListener('mousedown', (event) => {
      isDragging = true;
      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    document.addEventListener('mousemove', (event) => {
      if (!isDragging) return;

      const deltaMove = {
        x: event.clientX - previousMousePosition.x,
        y: event.clientY - previousMousePosition.y
      };

      const rotationSpeed = 0.005;

      grupo.rotation.y += deltaMove.x * rotationSpeed;
      grupo.rotation.x += deltaMove.y * rotationSpeed;

      previousMousePosition.x = event.clientX;
      previousMousePosition.y = event.clientY;
    });

    // Zoom com a roda do mouse
    window.addEventListener('wheel', (event) => {
      const zoomSpeed = 0.1;
      camera.position.z += event.deltaY * zoomSpeed;
      camera.position.z = Math.min(Math.max(camera.position.z, 2), 20);
    });

    // Ajuste responsivo
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Renderização contínua
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
